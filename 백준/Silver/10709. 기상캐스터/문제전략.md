# [Silver V] 기상캐스터 - 10709 

[문제 링크](https://www.acmicpc.net/problem/10709) 

### 성능 요약

메모리: 31120 KB, 시간: 60 ms

### 분류

구현, 시뮬레이션

### 제출 일자

2023년 11월 11일 21:00:03

### 문제 설명

<p>JOI시는 남북방향이 H 킬로미터, 동서방향이 W 킬로미터인 직사각형 모양이다. JOI시는 가로와 세로의 길이가 1킬로미터인 H × W 개의 작은 구역들로 나뉘어 있다. 북쪽으로부터 i 번째, 서쪽으로부터 j 번째에 있는 구역을 (i, j) 로 표시한다.</p>

<p>각 구역의 하늘에는 구름이 있을 수도, 없을 수도 있다. 모든 구름은 1분이 지날 때마다 1킬로미터씩 동쪽으로 이동한다. 오늘은 날씨가 정말 좋기 때문에 JOI시의 외부에서 구름이 이동해 오는 경우는 없다.</p>

<p>지금 각 구역의 하늘에 구름이 있는지 없는지를 알고 있다. 기상청에서 일하고 있는 여러분은 각 구역에 대해서 지금부터 몇 분뒤 처음으로 하늘에 구름이 오는지를 예측하는 일을 맡았다.</p>

<p>각 구역에 대해서 지금부터 몇 분뒤 처음으로 하늘에 구름이 오는지를 구하여라.</p>

### 입력 

 <p>입력은 1 + H 행으로 주어진다.</p>

<p>첫 번째 행에는 정수 H, W (1 ≦ H ≦ 100, 1 ≦ W ≦ 100) 가 공백을 사이에 주고 주어진다. 이것은 JOI시가 H × W 개의 작은 구역으로 나뉘어 있다는 것을 의미한다.</p>

<p>이어진 H 개의 행의 i번째 행 (1 ≦ i ≦ H) 에는 W문자의 문자열이 주어진다. W 개의 문자 중 j번째 문자 (1 ≦ j ≦ W) 는, 구역 (i, j) 에 지금 구름이 떠 있는지 아닌지를 나타낸다. 구름이 있는 경우에는 영어 소문자 'c' 가, 구름이 없는 경우에는 문자 '.' 가 주어진다.</p>

### 출력 

 <p>출력은 H 행으로, 각 행에는 공백으로 구분된 W 개의 정수를 출력한다. 출력의 i 번째 행 j 번째 정수 (1 ≦ i ≦ H, 1 ≦ j ≦ W) 는, 지금부터 몇 분후에 처음으로 구역 (i, j) 에 구름이 뜨는지를 표시한다. 단, 처음부터 구역 (i, j) 에 구름이 떠 있었던 경우에는 0을, 몇 분이 지나도 구름이 뜨지 않을 경우에는 -1을 출력한다.</p>

___
### 전략

#### [First grasp]
H를 행, W를 열로 둘 수가 있을 것.
모든 구름은 동쪽으로만 이동, 외부에서 구름이 추가되는 경우는 없음
즉 초기에 구름은 지도로서 주어지고 그 후에 구름은 1분뒤에 (i,j)에서 j만 바뀜.
현재 구름이 있다면 0분후에 오는 것이다라고 설정
하나 더 생각해봐야 할 것은, 한 지점을 구름이 여러번 거쳐갈 수 있는데 이 때는
처음 도달한 시간만 인정해야한다.

- 구름맵 초기화 (Ok.. acceptable startegy)
- 
##### [Process & What to improve]
- 문제를 풀면서 주의해야 하는건, 처음에 문자로 어떤 line을 한번에 리스트로 내려 받는데 그 경우
리스트의 요소 하나만 숫자로 바꾸는 것은 불가능 하다는걸 알아야 한다.

- 처음에 아이디어 접근할 때 cloud_index를 통해 뭔가 잡아내려고 했었던 것 같다. 해당 인덱스만 뽑아서 좀 더 쉽게 진행하는 건 없나?
  - 문제는 이렇게 아이디어를 잡아서 cloud_index를 뽑아내는건 했는데 이걸 제대로 활용을 못했음
  - 사실 cloud_index를 뽑아내어서 한번에 변경하려고 할 필요가 없지 않았나 싶다.

  ```
  if cloud_index!=[]: # 뭔가 구름이 있다고 할 때 처리해야함
          for k in range(0,W):
              if cloud_index.count(k)!=0:
                  Map_cloud_print[i][k]=0
              else:
                  Map_cloud_print[i][k]=-1
      else:
          for k in range(0, W):
              Map_cloud_print[i][k] = -1
      # [처리2] 1,2,3 등의 구름의 이동에 관한 처리
      # 순회하면서 보면 될 것 같음
      minute=-1
      for s in range(0,W):
          if (minute>0) and Map_cloud_print[i][s]!=0:
              Map_cloud_print[i][s]=minute # minute를 넣어준다,
              minute+=1 # 구름이 있다면 다음칸에도 들어가게 된다.
  
          if Map_cloud_print[i][s]==0: # 구름을 만났으니 minute 초기화
              minute=1 # 이제 구름을 만나서 카운팅 하기 시작할 것
  
      for q in range(W):
          print(Map_cloud_print[i][q],end=' ')
      print("")
    ``` 
    - 위의 코드에서 1,0 초기화의 경우에는 굳이 cloud_index를 사용할 필요가 아예 없었다.
    - 그러니 이 초기화는 좀 더 간단해 질 수 있었을 것이다.
    
    - 또한 코드에서 s를 반복문 돌려서 처리하는게 결국은 핵심이 된 것인데 앞서 말했듯, 어렵게 구름맵을 초기화할 필요가 없었다.
    - 그리고
    - ``` if (minute>0) and Map_cloud_print[i][s]!=0:
            Map_cloud_print[i][s]=minute # minute를 넣어준다,
            minute+=1 # 구름이 있다면 다음칸에도 들어가게 된다.

        if Map_cloud_print[i][s]==0: # 구름을 만났으니 minute 초기화
            minute=1 # 이제 구름을 만나서 카운팅 하기 시작할 것```
      
    - 이 부분도 간결하지 못했다. 구름을 만난것을 그냥 0으로 초기화를 하고, minute>=0으로 바로 넘어갔어도 문제는 없을 것
    ```
    for i in range(H):
      cnt=-1 # 'c' 만나지 못하면 계속 -1
      for j in range(W):
          if arr[i][j]=='c': # 구름을 만나면 0으로 초기화
              cnt=0
          else:
              if cnt>=0:
                  cnt+=1
          v[i][j]=cnt
    ```
    - 이 같이 cnt를 처리하면 line을 한번에 초기화 할수도 있으며, 구름을 매번 만날때 마다 cnt=0으로 만들어 주고 그렇지 않으면
매번 cnt를 증가시킨다. 어떻게? cnt=0 인 상황에서 if 조건절을 추가해서. <B>사실은 저 부분이 핵심이다. 바로 구름이 존재해야만 cnt=0 으로 한번 값이 바뀐다는 사실.
그리고 if 조건문은 결국 구름이 해당 행에 한번이라도 있니? 라고 물어보고 있다는 것.</B>
 

