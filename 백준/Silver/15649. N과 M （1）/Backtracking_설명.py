# 다음은 백트래킹이다.
'''
for문에서 1~N을 선택, 이를 결과 값에 추가.
이후 재귀 함수 호출 이 때 중복 없이 선택하는 방법이 필요함
그리고 이 때 방문 여부를 체크해 볼 수 있음 그렇게 해서 방문을 안한 것만 돌려볼 수 있음
백트래킹은 특정 레벨의 바운더리를 정해서 그 바운더리에 부딪히면 다시 튕긴다가 핵심이다.
'''
import sys
input=sys.stdin.readline
N,M=map(int,input().split())
rs=[]
chk=[False]*(N+1)

def recur(num):
    if num==M:
        print(' '.join(map(str,rs)))
        return
    for i in range(1,N+1):
        if chk[i]==False:
            chk[i]=True # 노드 방문처리
            rs.append(i) # 노드를 더해줌
            recur(num+1) # 노드를 순회한 횟수를 의미함!(중요)
            chk[i]=False # 이게 중요한데 방문처리한 노드를 다시 recur 재귀 함수를 실행한 후에는 되돌려야 한다.
            rs.pop()
recur(0)

'''
예를 들어 N=3, M=2으로서, 1->2 이렇게 노드가 방문을 했다 치면
1. num(0)에서 1,2,3번 노드 순회
2. chk[1] 이 False
3. 1번 노드 방문처리, 1 append, 현재까지는 노드를 1번 방문한 것
4. recur(1)을 실행, 1번 노드에서 1번 2번 3번 노드 순회여부 파악 후, 1번 노드 방문했으므로 2번 노드를 순회.
5. 2번노드를 방문했더니 즉, recur(2)가 되었더니 num==2로 중복 없이 2회 방문하였음 이에 함수를 종료 (rs=[1,2])
6. recur(1) 함수로 돌아가게 됨, recur(1) 내부 for 문 반복에서 방문한 2번 노드는 다시 비워야함 그래서 chk[2]->False로 하고 pop 시켜줌
7. for문에서 3번노드를 대상으로 실행하여 위의 과정을 반복 (현재 rs의 상태는 rs=[1] 임)
8. 마찬가지로 recur(2)를 실행을 하게 되는건 같은데 이번에는 chk에는 1,3번 노드가 방문처리가 되어있을것 (rs=[1,3])
9. 3번노드에서 2번노드와 같은 과정으로 진행됨 (rs=[1])
10. recur(1)에서 for문은 모두 수행한 셈이 된다. 더 상위 재귀문인 recur(0)로 돌아감
11. recur(0)의 반복문에서 recur(1)의 내용이 끝났으므로 rs=[1]->rs[]로 바뀌게 된다.
12. 위의 과정을 계속 반복함.

결과적으로 여기서 backtracking은 하나의 branch (tree)를 모두 수행을 해야만, 다음 branch가 진행되는 구조임을 알 수 있다.
'''
